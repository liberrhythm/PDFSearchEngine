Optimization Monte Carlo: Efficient and
Embarrassingly Parallel Likelihood-Free Inference

Max Welling‚àó
Informatics Institute
University of Amsterdam
welling.max@gmail.com

Edward Meeds
Informatics Institute
University of Amsterdam
tmeeds@gmail.com

Abstract
We describe an embarrassingly parallel, anytime Monte Carlo method for
likelihood-free models. The algorithm starts with the view that the stochasticity of the pseudo-samples generated by the simulator can be controlled externally
by a vector of random numbers u, in such a way that the outcome, knowing u,
is deterministic. For each instantiation of u we run an optimization procedure to
minimize the distance between summary statistics of the simulator and the data.
After reweighing these samples using the prior and the Jacobian (accounting for
the change of volume in transforming from the space of summary statistics to the
space of parameters) we show that this weighted ensemble represents a Monte
Carlo estimate of the posterior distribution. The procedure can be run embarrassingly parallel (each node handling one sample) and anytime (by allocating
resources to the worst performing sample). The procedure is validated on six experiments.

1

Introduction

Computationally demanding simulators are used across the full spectrum of scientific and industrial
applications, whether one studies embryonic morphogenesis in biology, tumor growth in cancer
research, colliding galaxies in astronomy, weather forecasting in meteorology, climate changes in
the environmental science, earthquakes in seismology, market movement in economics, turbulence
in physics, brain functioning in neuroscience, or fabrication processes in industry. Approximate
Bayesian computation (ABC) forms a large class algorithms that aims to sample from the posterior
distribution over parameters for these likelihood-free (a.k.a. simulator based) models. Likelihoodfree inference, however, is notoriously inefficient in terms of the number of simulation calls per
independent sample. Further, like regular Bayesian inference algorithms, care must be taken so that
posterior sampling targets the correct distribution.
The simplest ABC algorithm, ABC rejection sampling, can be fully parallelized by running independent processes with no communication or synchronization requirements. I.e. it is an embarrassingly
parallel algorithm. Unfortunately, as the most inefficient ABC algorithm, the benefits of this title are limited. There has been considerable progress in distributed MCMC algorithms aimed at
large-scale data problems [2, 1]. Recently, a sequential Monte Carlo (SMC) algorithm called ‚Äúthe
particle cascade‚Äù was introduced that emits streams of samples asynchronously with minimal memory management and communication [17]. In this paper we present an alternative embarrassingly
parallel sampling approach: each processor works independently, at full capacity, and will indefinitely emit independent samples. The main trick is to pull random number generation outside of the
simulator and treat the simulator as a deterministic piece of code. We then minimize the difference
‚àó
Donald Bren School of Information and Computer Sciences University of California, Irvine, and Canadian
Institute for Advanced Research.

1

between observations and the simulator output over its input parameters and weight the final (optimized) parameter value with the prior and the (inverse of the) Jacobian. We show that the resulting
weighted ensemble represents a Monte Carlo estimate of the posterior. Moreover, we argue that the
error of this procedure is O() if the optimization gets -close to the optimal value. This ‚ÄúOptimization Monte Carlo‚Äù (OMC) has several advantages: 1) it can be run embarrassingly parallel, 2)
the procedure generates independent samples and 3) the core procedure is now optimization rather
than MCMC. Indeed, optimization as part of a likelihood-free inference procedure has recently been
proposed [12]; using a probabilistic model of the mapping from parameters to differences between
observations and simulator outputs, they apply ‚ÄúBayesian Optimization‚Äù (e.g. [13, 21]) to efficiently
perform posterior inference. Note also that since random numbers have been separated out from the
simulator, powerful tools such as ‚Äúautomatic differentiation‚Äù (e.g. [14]) are within reach to assist
with the optimization. In practice we find that OMC uses far fewer simulations per sample than
alternative ABC algorithms.
The approach of controlling randomness as part of an inference procedure is also found in a related
class of parameter estimation algorithms called indirect inference [11]. Connections between ABC
and indirect inference have been made previously by [7] as a novel way of creating summary statistics. An indirect inference perspective led to an independently developed version of OMC called the
‚Äúreverse sampler‚Äù [9, 10].
In Section 2 we briefly introduce ABC and present it from a novel viewpoint in terms of random
numbers. In Section 3 we derive ABC through optimization from a geometric point of view, then
proceed to generalize it to higher dimensions. We show in Section 4 extensive evidence of the
correctness and efficiency of our approach. In Section 5 we describe the outlook for optimizationbased ABC.

2

ABC Sampling Algorithms

The primary interest in ABC is the posterior of simulator parameters Œ∏ given a vector of (statistics
of) observations y, p(Œ∏|y). The likelihood p(y|Œ∏) is generally not available in ABC. Instead we can
use the simulator as a generator of pseudo-samples x that reside in the same space as y. By treating
x as auxiliary variables, we can continue with the Bayesian treatment:
R
p(Œ∏) p (y|x)p(x|Œ∏) dx
p(Œ∏)p(y|Œ∏)
R
p(Œ∏|y) =
‚âàR
(1)
p(y)
p(Œ∏) p (y|x)p(x|Œ∏) dx dŒ∏
Of particular importance is the choice of kernel measuring the discrepancy between observations y
and pseudo-data x. Popular choices for kernels are the Gaussian kernel and the uniform -tube/ball.
The bandwidth parameter  (which may be a vector  accounting for relative importance of each
statistic) plays critical role: small  produces more accurate posteriors, but is more computationally
demanding, whereas large  induces larger error but is cheaper.
We focus our attention on population-based ABC samplers, which include rejection sampling, importance sampling (IS), sequential Monte Carlo (SMC) [6, 20] and population Monte Carlo [3]. In
rejection sampling, we draw parameters from the prior Œ∏ ‚àº p(Œ∏), then run a simulation at those
parameters x ‚àº p(x|Œ∏); if the discrepancy œÅ(x, y) < , then the particle is accepted, otherwise it
is rejected. This is repeated until n particles are accepted. Importance sampling generalizes rejection sampling using a proposal distribution qœÜ (Œ∏) instead of the prior, and produces samples with
weights wi ‚àù p(Œ∏)/q(Œ∏). SMC extends IS to multiple rounds with decreasing , adapting their particles after each round, such that each new population improves the approximation to the posterior.
Our algorithm has similar qualities to SMC since we generate a population of n weighted particles,
but differs significantly since our particles are produced by independent optimization procedures,
making it completely parallel.

3

A Parallel and Efficient ABC Sampling Algorithm

Inherent in our assumptions about the simulator is that internally there are calls to a random number
generator which produces the stochasticity of the pseudo-samples. We will assume for the moment
that this can be represented by a vector of uniform random numbers u which, if known, would
make the simulator deterministic. More concretely, we assume that any simulation output x can
be represented as a deterministic function of parameters Œ∏ and a vector of random numbers u,
2

(a) DŒ∏ = Dy

(b) DŒ∏ < Dy

Figure 1: Illustration of OMC geometry. (a) Dashed lines indicate contours f (Œ∏, u) over Œ∏ for several u. For
three values of u, their initial and optimal Œ∏ positions are shown (solid blue/white circles). Within the grey
acceptance region, the Jacobian, indicated by the blue diagonal line, describes the relative change in volume
induced in f (Œ∏, u) from a small change in Œ∏. Corresponding weights ‚àù 1/|J| are shown as vertical stems. (b)
When DŒ∏ < Dy , here 1 < 2, the change in volume is proportional to the length of the line segment inside the
ellipsoid (|JT J|1/2 ). The orange line indicates the projection of the observation onto the contour of f (Œ∏, u) (in
this case, identical to the optimal).

i.e. x = f (Œ∏, u). This assumption has been used previously in ABC, first in ‚Äúcoupled ABC‚Äù
[16] and also in an application of Hamiltonian dynamics to ABC [15]. We do not make any further
assumptions regarding u or p(u), though for some problems their dimension and distribution may be
known a priori. In these cases it may be worth employing Sobol or other low-discrepancy sequences
to further improve the accuracy of any Monte Carlo estimates.
We will first derive a dual representation for the ABC likelihood function p (y|Œ∏) (see also [16]),
Z
Z Z
p (y|Œ∏) = p (y|x)p(x|Œ∏) dx =
p (y|x)I[x = f (Œ∏, u)]p(u) dxdu
(2)
Z
= p (y|f (Œ∏, u))p(u) du
(3)
leading to the following Monte Carlo approximation of the ABC posterior,
Z
1X
p (Œ∏|y) ‚àù p(Œ∏) p(u)p (y|f (u, Œ∏)) du ‚âà
p (y|f (ui , Œ∏))p(Œ∏)
n i

ui ‚àº p(u)

(4)

Since p is a kernel that only accepts arguments y and f (ui , Œ∏) that are  close to each other (for
values of  that are as small as possible), Equation 4 tells us that we should first sample values for
u from p(u) and then for each such sample find the value for Œ∏io that results in y = f (Œ∏io , u). In
practice we want to drive these values as close to each other as possible through optimization and
accept an O() error if the remaining distance is still O(). Note that apart from sampling the values
for u this procedure is deterministic and can be executed completely in parallel, i.e. without any
communication. In the following we will assume a single observation vector y, but the approach is
equally applicable to a dataset of N cases.
3.1 The case DŒ∏ = Dy
We will first study the case when the number of parameters Œ∏ is equal to the number of summary
statistics y. To understand the derivation it helps to look at Figure 1a which illustrates the derivation
for the one dimensional case. In the following we use the following abbreviation: fi (Œ∏) stands for
f (Œ∏, ui ). The general idea is that we want to write the approximation to the posterior as a mixture
of small uniform balls (or delta peaks in the limit):
1X
1X
p (y|f (ui , Œ∏))p(Œ∏) ‚âà
wi U (Œ∏|Œ∏i‚àó )p(Œ∏)
(5)
p(Œ∏|y) ‚âà
n i
n i
3

with wi some weights that we will derive shortly. Then, if we make  small enough we can replace
any average of a sufficiently smooth function h(Œ∏) w.r.t. this approximate posterior simply by evaluating h(Œ∏) at some arbitrarily chosen points inside these balls (for instance we can take the center
of the ball Œ∏i‚àó ),
Z
1X
h(Œ∏)p(Œ∏|y) dŒ∏ ‚âà
h(Œ∏i‚àó )wi p(Œ∏i‚àó )
(6)
n i
To derive this expression we first assume that:
p (y|fi (Œ∏)) = C()I[||y ‚àí fi (Œ∏)||2 ‚â§ 2 ]

(7)

i.e. a ball of radius . C() is the normalizer which is immaterial because it cancels in the posterior.
For small enough  we claim that we can linearize fi (Œ∏) around Œ∏io :
fÃÇi (Œ∏) = fi (Œ∏io ) + Joi (Œ∏ ‚àí Œ∏io ) + Ri ,

Ri = O(||Œ∏ ‚àí Œ∏io ||2 )

(8)

‚àÇfi (Œ∏io )

where Joi is the Jacobian matrix with columns ‚àÇŒ∏d . We take Œ∏io to be the end result of our
optimization procedure for sample ui . Using this we thus get,
||y ‚àí fi (Œ∏)||2 ‚âà ||(y ‚àí fi (Œ∏io )) ‚àí Joi (Œ∏ ‚àí Œ∏io ) ‚àí Ri ||2

(9)

We first note that since we assume that our optimization has ended up somewhere inside the ball
defined by ||y ‚àí fi (Œ∏)||2 ‚â§ 2 we can assume that ||y ‚àí fi (Œ∏io )|| = O(). Also, since we only
consider values for Œ∏ that satisfy ||y ‚àí fi (Œ∏)||2 ‚â§ 2 , and furthermore assume that the function
fi (Œ∏) is Lipschitz continuous in Œ∏ it follows that ||Œ∏ ‚àí Œ∏io || = O() as well. All of this implies
that we can safely ignore the remaining term Ri (which is of order O(||Œ∏ ‚àí Œ∏io ||2 ) = O(2 )) if we
restrict ourselves to the volume inside the ball.
The next step is to view the term I[||y ‚àí fi (Œ∏)||2 ‚â§ 2 ] as a distribution in Œ∏. With the Taylor
expansion this results in,
o,‚àí1
o
o
(y ‚àí fi (Œ∏io ))) ‚â§ 2 ]
I[(Œ∏ ‚àí Œ∏io ‚àí Jo,‚àí1
(y ‚àí fi (Œ∏io )))T JoT
i Ji (Œ∏ ‚àí Œ∏i ‚àí Ji
i

This represents an ellipse in Œ∏-space with a centroid Œ∏i‚àó and volume Vi given by
Œ≥
Œ∏i‚àó = Œ∏io + Jio,‚àí1 (y ‚àí fi (Œ∏io ))
Vi = q
o
det(JoT
i Ji )
with Œ≥ a constant independent of i. We can approximate the posterior now as,
1 X Œ¥(Œ∏ ‚àí Œ∏i‚àó )p(Œ∏i‚àó )
1 X U (Œ∏|Œ∏i‚àó )p(Œ∏)
q
q
‚âà
p(Œ∏|y) ‚âà
Œ∫ i
Œ∫ i
o
o
det(JoT
det(JoT
i Ji )
i Ji )

(10)

(11)

(12)

where in the last P
step we have send  ‚Üí 0. Finally, we can compute the constant Œ∫ through noroT o ‚àí1/2
‚àó
malization, Œ∫ =
. The whole procedure is accurate up to errors of the
i p(Œ∏i ) det(Ji Ji )
order O(2 ), and it is assumed that the optimization procedure delivers a solution that is located
within the epsilon ball. If one of the optimizations for a certain sample ui did not end up within
the epsilon ball there can be two reasons: 1) the optimization did not converge to the optimal value
for Œ∏, or 2) for this value of u there is no solution for which f (Œ∏|u) can get within a distance 
from the observation y. If we interpret  as our uncertainty in the observation y, and we assume that
our optimization succeeded in finding the best possible value for Œ∏, then we should simply reject
this sample Œ∏i . However, it is hard to detect if our optimization succeeded and we may therefore
sometimes reject samples that should not have been rejected. Thus, one should be careful not to
create a bias against samples ui for which the optimization is difficult. This situation is similar to a
sampler that will not mix to remote local optima in the posterior distribution.
3.2 The case DŒ∏ < Dy
This is the overdetermined case and here the situation as depicted in Figure 1b is typical: the manifold that f (Œ∏, ui ) traces out as we vary Œ∏ forms a lower dimensional surface in the Dy dimensional
enveloping space. This manifold may or may not intersect with the sphere centered at the observation y (or ellipsoid, for the general case  instead of ). Assume that the manifold does intersect the
4

epsilon ball but not y. Since we trust our observation up to distance , we may simple choose to
pick the closest point Œ∏i‚àó to y on the manifold, which is given by,
o
Œ∏i‚àó = Œ∏io + Jo‚Ä†
i (y ‚àí fi (Œ∏i ))

oT o ‚àí1 oT
Jo‚Ä†
Ji
i = (Ji Ji )

(13)

Jo‚Ä†
i

is the pseudo-inverse. We can now define our ellipse around this point, shifting the
where
center of the ball from y to fi (Œ∏i‚àó ) (which do not coincide in this case). The uniform distribution
on the ellipse in Œ∏-space is now defined in the DŒ∏ dimensional manifold and has volume Vi =
o ‚àí1/2
Œ≥ det(JoT
. So once again we arrive at almost the same equation as before (Eq. 12) but with
i Ji )
the slightly different definition of the point Œ∏i‚àó given by Eq. 13. Crucially, since ||y ‚àí fi (Œ∏i‚àó )|| ‚â§ 2
and if we assume that our optimization succeeded, we will only make mistakes of order O(2 ).
3.3 The case DŒ∏ > Dy
This is the underdetermined case in which it is typical that entire manifolds (e.g. hyperplanes) may
be a solution to ||y ‚àí fi (Œ∏i‚àó )|| = 0. In this case we can not approximate the posterior with a
mixture of point masses and thus the procedure does not apply. However, the case DŒ∏ > Dy is less
interesting than the other ones above as we expect to have more summary statistics than parameters
for most problems.

4

Experiments

The goal of these experiments is to demonstrate 1) the correctness of OMC and 2) the relative
efficiency of OMC in relation to two sequential MC algorithms, SMC (aka population MC [3]) and
adaptive weighted SMC [5]. To demonstrate correctness, we show histograms of weighted samples
along with the true posterior (when known) and, for three experiments, the exact OMC weighted
samples (when the exact Jacobian and optimal Œ∏ is known). To demonstrate efficiency, we compute
the mean simulations per sample (SS)‚Äîthe number of simulations required to reach an  threshold‚Äî
and the effective sample size (ESS), defined as 1/wT w. Additionally, we may measure ESS/n, the
fraction of effective samples in the population. ESS is a good way of detecting whether the posterior
is dominated by a few particles and/or how many particles achieve discrepancy less than epsilon.
There are several algorithmic options for OMC. The most obvious is to spawn independent processes, draw u for each, and optimize until  is reached (or a max nbr of simulations run), then
compute Jacobians and particle weights. Variations could include keeping a sorted list of discrepancies and allocating computational resources to the worst particle. However, to compare OMC with
SMC, in this paper we use a sequential version of OMC that mimics the epsilon rounds of SMC.
Each simulator uses different optimization procedures, including Newton‚Äôs method for smooth simulators, and random walk optimization for others; Jacobians were computed using one-sided finite
differences. To limit computational expense we placed a max of 1000 simulations per sample per
round for all algorithms. Unless otherwise noted, we used n = 5000 and repeated runs 5 times; lack
of error bars indicate very low deviations across runs. We also break some of the notational convention used thus far so that we can specify exactly how the random numbers translate into pseudo-data
and the pseudo-data into statistics. This is clarified for each example. Results are explained in
Figures 2 to 4.
4.1

Normal with Unknown Mean and Known Variance

The simplest example is the inference of the mean Œ∏ of a univariate normal distribution with known
variance œÉ 2 . The prior distribution œÄ(Œ∏) is normal with mean Œ∏0 and variance kœÉ 2 , where k > 0 is
a factor relating the dispersions of Œ∏ and the data yn . The simulator can generate data according to
the normal distribution, or deterministically if the random effects rum are known:
œÄ(xm |Œ∏) = N (xm |Œ∏, œÉ 2 )
=‚áí
xm = Œ∏ + rum
(14)
‚àö
‚àí1
where rum = œÉ 2 erf P(2um ‚àí 1) (using the inverse CDF). A sufficient statistic for this P
problem is
1
the average s(x) = M
rum /M
m xm . Therefore we have f (Œ∏, u) = Œ∏ + R(u) where R(u) =
(the average of the random effects). In our experiment we set M = 2 and y = 0. The exact
Jacobian and Œ∏io can be computed for this problem: for a draw ui , Ji = 1; if s(y) is the mean of the
observations y, then by setting f (Œ∏io , ui ) = s(y) we find Œ∏io = s(y) ‚àí R(ui ). Therefore the exact
weights are wi ‚àù œÄ(Œ∏io ), allowing us to compare directly with an exact posterior based on our dual
representation by u (shown by orange circles in Figure 2 top-left). We used Newton‚Äôs method to
optimize each particle.
5

Figure 2: Left: Inference of unknown mean. For  0.1, OMC uses 3.7 SS; AW/SMC uses 20/20 SS; at  0.01,
OMC uses 4 SS (only 0.3 SS more), and SMC jumps to 110 SS. For all algorithms and  values, ESS/n=1.
Right: Inference for mixture of normals. Similar results for OMC; at  0.025 AW/SMC had 40/50 SS and at
 0.01 has 105/120 SS. The ESS/n remained at 1 for OMC, but decreased to 0.06/0.47 (AW/SMC) at  0.025,
and 0.35 for both at  0.01. Not only does the ESS remain high for OMC, but it also represents the tails of the
distribution well, even at low .
4.2 Normal Mixture
A standard illustrative ABC problem is the inference of the mean Œ∏ of a mixture of two normals
[19, 3, 5]: p(x|Œ∏) = œÅ N (Œ∏, œÉ12 ) + (1 ‚àí œÅ) N (Œ∏, œÉ22 ), with œÄ(Œ∏) = U(Œ∏a , Œ∏b ) where hyperparameters
are œÅ = 1/2, œÉ12 = 1, œÉ22 = 1/100, Œ∏a = ‚àí10, Œ∏b = 10, and a single observation scalar y = 0.
For this problem M = 1 so we drop the subscript m. The true posterior is simply p(Œ∏|y = 0) ‚àù
œÅ N (Œ∏, œÉ12 ) + (1 ‚àí œÅ) N (Œ∏, œÉ22 ), Œ∏ ‚àà {‚àí10, 10}. In this problem there are two random numbers u1
and u2 , one for selecting the mixture component and the other for the random innovation; further,
the statistic is the identity, i.e. s(x) = x:
‚àö
‚àö
(15)
x = [u1 < œÅ](Œ∏ + œÉ1 2 erf(2u2 ‚àí 1)) + [u1 ‚â• œÅ](Œ∏ + œÉ2 2 erf(2u2 ‚àí 1))
‚àö
[u1 <œÅ] [u1 ‚â•œÅ]
œÉ2
= Œ∏ + R(u)
(16)
= Œ∏ + 2 erf(2u2 ‚àí 1)œÉ1
‚àö
[u1 <œÅ] [u1 ‚â•œÅ]
where R(u) = 2 erf(2u2 ‚àí 1)œÉ1
œÉ2
. As with the previous example, the Jacobian is 1
and Œ∏io = y ‚àí R(ui ) is known exactly. This problem is notable for causing performance issues in
ABC-MCMC [19] and its difficulty in targeting the tails of the posterior [3]; this is not the case for
OMC.
4.3 Exponential with Unknown Rate
In this example, the goal is to infer the rate Œ∏ of an exponential distribution, with a gamma prior
p(Œ∏) = Gamma(Œ∏|Œ±, Œ≤), based on M draws from Exp(Œ∏):
1
1
(17)
p(xm |Œ∏) = Exp(xm |Œ∏) = Œ∏ exp(‚àíŒ∏xm ) =‚áí xm = ‚àí ln(1 ‚àí um ) = rum
Œ∏
Œ∏
where rum = ‚àí ln(1 ‚àí um ) (the
Pinverse CDF of the exponential). A sufficient statistic for this
problem is the average s(x) =
m xm /M . Again, we have exact expressions for the Jacobian
o
and Œ∏i , using f (Œ∏, ui ) = R(ui )/Œ∏, Ji = ‚àíR(ui )/Œ∏2 and Œ∏io = R(ui )/s(y). We used M = 2,
s(y) = 10 in our experiments.
4.4 Linked Mean and Variance of Normal
In this example we link together the mean and variance of the data generating function as follows:
‚àö
=‚áí
xm = Œ∏ + Œ∏ 2 erf ‚àí1 (2um ‚àí 1) = Œ∏rum
(18)
p(xm |Œ∏) = N (xm |Œ∏, Œ∏2 )
6

Figure 3: Left: Inference of rate of exponential. A similar result wrt SS occurs for this experiment: at  1,
OMC had 15 v 45/50 for AW/SMC; at  0.01, SS was 28 OMC v 220 AW/SMC. ESS/n dropping with below
1: OMC drops at  1 to 0.71 v 0.97 for SMC; at  0.1 ESS/n remains the same. Right: Inference of linked
normal. ESS/n drops significantly for OMC: at  0.25 to 0.32 and at  0.1 to 0.13, while it remains high
for SMC (0.91 to 0.83). This is the result the inability of every ui to achieve œÅ < , whereas for SMC, the
algorithm allows them to ‚Äúdrop‚Äù their random numbers and effectively switch to another. This was verified
by running an expensive fine-grained optimization, resulting in 32.9% and 13.6% optimized particles having
œÅ under  0.25/0.1. Taking this inefficiency into account, OMC still requires 130 simulations per effective
sample v 165 for SMC (ie 17/0.13 and 136/0.83).
‚àö
where rum = 1 + 2 erf ‚àí1 (2um ‚àí 1). We put a positive constraint on Œ∏: p(Œ∏) = U(0, 10). We used
2 statistics, the mean and variance of M draws from the simulator:
1
‚àÇf1 (Œ∏, u)
s1 (x) =
xm
=‚áí f1 (Œ∏, u) = Œ∏R(u)
= R(u)
(19)
M
‚àÇŒ∏
‚àÇf2 (Œ∏, u)
1 X
(xm ‚àí s1 (x))2
=‚áí f2 (Œ∏, u) = Œ∏2 V (u)
= 2Œ∏V (u) (20)
s2 (x) =
M m
‚àÇŒ∏
P
P
where V (u) = m ru2 m /M ‚àí R(u)2 and R(u) = m rum /M ; the exact Jacobian is therefore
[R(u), 2Œ∏V (u)]T . In our experiments M = 10, s(y) = [2.7, 12.8].
4.5 Lotka-Volterra
The simplest Lotka-Volterra model explains predator-prey populations over time, controlled by a set
of stochastic differential equations:
dx1
dx2
= Œ∏1 x1 ‚àí Œ∏2 x1 x2 + r1
= ‚àíŒ∏2 x2 ‚àí Œ∏3 x1 x2 + r2
(21)
dt
dt
where x1 and x2 are the prey and predator population sizes, respectively. Gaussian noise r ‚àº
N (0, 102 ) is added at each full time-step. Lognormal priors are placed over Œ∏. The simulator
runs for T = 50 time steps, with constant initial populations of 100 for both prey and predator.
There is therefore P = 2T outputs (prey and predator populations concatenated), which we use
as the statistics. To run a deterministic simulation, we draw ui ‚àº œÄ(u) where the dimension of
u is P . Half
‚àö of the random variables are used for r1 and the other half for r2 . In other words,
rust = 10 2 erf ‚àí1 (2ust ‚àí 1), where s ‚àà {1, 2} for the appropriate population. The Jacobian is a
100√ó3 matrix that can be computed using one-sided finite-differences using 3 forward simulations.
4.6 Bayesian Inference of the M/G/1 Queue Model
Bayesian inference of the M/G/1 queuing model is challenging, requiring ABC algorithms [4, 8] or
sophisticated MCMC-based procedures [18]. Though simple to simulate, the output can be quite
7

Figure 4: Top: Lotka-Volterra. Bottom: M/G/1 Queue. The left plots shows the posterior mean ¬±1 std errors
of the posterior predictive distribution (sorted for M/G/1). Simulations per sample and the posterior of Œ∏1 are
shown in the other plots. For L-V, at  3, the SS for OMC were 15 v 116/159 for AW/SMC, and increased
at  2 to 23 v 279/371. However, the ESS/n was lower for OMC: at  3 it was 0.25 and down to 0.1 at  2,
whereas ESS/n stayed around 0.9 for AW/SMC. This is again due to the optimal discrepancy for some u being
greater than ; however, the samples that remain are independent samples. For M/G/1, the results are similar,
but the ESS/n is lower than the number of discrepancies satisfying  1, 9% v 12%, indicating that the volume
of the Jacobians is having a large effect on the variance of the weights. Future work will explore this further.

noisy. In the M/G/1 queuing model, a single server processes arriving customers, which are then
served within a random time. Customer m arrives at time wm ‚àº Exp(Œ∏3 ) after customer m ‚àí 1, and
is served in sm ‚àº U(Œ∏1 , Œ∏2 ) service time. Both wm and sm are unobserved; only the inter-departure
times xm are observed. Following [18], we write the simulation algorithm in terms of arrival times
vm . To simplify the updates, we keep track of the departure times dm . Initially, d0 = 0 and v0 = 0,
followed by updates for m ‚â• 1:
vm = vm‚àí1 + wm

xm = sm + max(0, vm ‚àí dm‚àí1 )

dm = dm‚àí1 + xm

(22)

After trying several optimization procedures, we found the most reliable optimizer was simply a
random walk. The random sources in the problem used for Wm (there are M ) and for Um (there are
M ), therefore u is dimension 2M . Typical statistics for this problem are quantiles of x and/or the
minimum and maximum values; in other words, the vector x is sorted then evenly spaced values for
the statistics functions f (we used 3 quantiles). The Jacobian is an M √ó3 matrix. In our experiments
Œ∏‚àó = [1.0, 5.0, 0.2]

5

Conclusion

We have presented Optimization Monte Carlo, a likelihood-free algorithm that, by controlling the
simulator randomness, transforms traditional ABC inference into a set of optimization procedures.
By using OMC, scientists can focus attention on finding a useful optimization procedure for their
simulator, and then use OMC in parallel to generate samples independently. We have shown that
OMC can also be very efficient, though this will depend on the quality of the optimization procedure applied to each problem. In our experiments, the simulators were cheap to run, allowing
Jacobian computations using finite differences. We note that for high-dimensional input spaces and
expensive simulators, this may be infeasible, solutions include randomized gradient estimates [22]
or automatic differentiation (AD) libraries (e.g. [14]). Future work will include incorporating AD,
improving efficiency using Sobol numbers (when the size u is known), incorporating Bayesian optimization, adding partial communication between processes, and inference for expensive simulators
using gradient-based optimization.
Acknowledgments
We thank the anonymous reviewers for the many useful comments that improved this manuscript.
MW acknowledges support from Facebook, Google, and Yahoo.
8

References
[1] Ahn, S., Korattikara, A., Liu, N., Rajan, S., and Welling, M. (2015). Large scale distributed Bayesian
matrix factorization using stochastic gradient MCMC. In KDD.
[2] Ahn, S., Shahbaba, B., and Welling, M. (2014). Distributed stochastic gradient MCMC. In Proceedings of
the 31st International Conference on Machine Learning (ICML-14), pages 1044‚Äì1052.
[3] Beaumont, M. A., Cornuet, J.-M., Marin, J.-M., and Robert, C. P. (2009). Adaptive approximate Bayesian
computation. Biometrika, 96(4):983‚Äì990.
[4] Blum, M. G. and FrancÃßois, O. (2010). Non-linear regression models for approximate Bayesian computation. Statistics and Computing, 20(1):63‚Äì73.
[5] Bonassi, F. V. and West, M. (2015). Sequential Monte Carlo with adaptive weights for approximate
Bayesian computation. Bayesian Analysis, 10(1).
[6] Del Moral, P., Doucet, A., and Jasra, A. (2006). Sequential Monte Carlo samplers. Journal of the Royal
Statistical Society: Series B (Statistical Methodology), 68(3):411‚Äì436.
[7] Drovandi, C. C., Pettitt, A. N., and Faddy, M. J. (2011). Approximate Bayesian computation using indirect
inference. Journal of the Royal Statistical Society: Series C (Applied Statistics), 60(3):317‚Äì337.
[8] Fearnhead, P. and Prangle, D. (2012). Constructing summary statistics for approximate Bayesian computation: semi-automatic approximate Bayesian computation. Journal of the Royal Statistical Society: Series
B (Statistical Methodology), 74(3):419‚Äì474.
[9] Forneron, J.-J. and Ng, S. (2015a). The ABC of simulation estimation with auxiliary statistics. arXiv
preprint arXiv:1501.01265v2.
[10] Forneron, J.-J. and Ng, S. (2015b). A likelihood-free reverse sampler of the posterior distribution. arXiv
preprint arXiv:1506.04017v1.
[11] Gourieroux, C., Monfort, A., and Renault, E. (1993). Indirect inference. Journal of applied econometrics,
8(S1):S85‚ÄìS118.
[12] Gutmann, M. U. and Corander, J. (2015). Bayesian optimization for likelihood-free inference of
simulator-based statistical models. Journal of Machine Learning Research, preprint arXiv:1501.03291.
In press.
[13] Jones, D. R., Schonlau, M., and Welch, W. J. (1998). Efficient global optimization of expensive black-box
functions. Journal of Global optimization, 13(4):455‚Äì492.
[14] Maclaurin, D. and Duvenaud, D. (2015). Autograd. github.com/HIPS/autograd.
[15] Meeds, E., Leenders, R., and Welling, M. (2015). Hamiltonian ABC. Uncertainty in AI, 31.
[16] Neal, P. (2012). Efficient likelihood-free Bayesian computation for household epidemics. Statistical
Computing, 22:1239‚Äì1256.
[17] Paige, B., Wood, F., Doucet, A., and Teh, Y. W. (2014). Asynchronous anytime Sequential Monte Carlo.
In Advances in Neural Information Processing Systems, pages 3410‚Äì3418.
[18] Shestopaloff, A. Y. and Neal, R. M. (2013). On Bayesian inference for the M/G/1 queue with efficient
MCMC sampling. Technical Report, Dept. of Statistics, University of Toronto.
[19] Sisson, S., Fan, Y., and Tanaka, M. M. (2007). Sequential Monte Carlo without likelihoods. Proceedings
of the National Academy of Sciences, 104(6).
[20] Sisson, S., Fan, Y., and Tanaka, M. M. (2009). Sequential Monte Carlo without likelihoods: Errata.
Proceedings of the National Academy of Sciences, 106(16).
[21] Snoek, J., Larochelle, H., and Adams, R. P. (2012). Practical Bayesian optimization of machine learning
algorithms. Advances in Neural Information Processing Systems 25.
[22] Spall, J. C. (1992). Multivariate stochastic approximation using a simultaneous perturbation gradient
approximation. Automatic Control, IEEE Transactions on, 37(3):332‚Äì341.

9

